# функция - это фрагмент программы, используемой многократно

# Необходимо создать функцию sumNumbers(n), которая будет считать сумму всех элементов от 1 до n

# с циклом while
# def sumNumbers(n):
#     sum = 1
#     while n > 1:
#         sum = sum + n
#         n -= 1
#     return sum

# print(sumNumbers(5))


# с циклом for
# def sumNumbers(n):
#     sum = 0
#     for i in range(1, n+1):
#         sum += i
#     return sum
# print(sumNumbers(5))


# та же задача, только запрашиваем число n у пользователя
# def sumNumbers(n):
#     sum = 0
#     for i in range(1, n+1):
#         sum += i
#     return sum

# n = int(input("введите число "))
# print(sumNumbers(n))

##################################################################
# задача. передать нашей функции множество букв и получить единое слово

# def summ_str(*args): # мы не знаем сколько аргументв будем передавать в функцию, поэтому ставим звездочку
#     result = ''
#     for i in args:
#         result += i
#     return result

# print(summ_str('q', 'e', 'w', 'r', 't'))  


##################################################################
#                        МОДУЛЬНОСТЬ, ИМПОРТ
##################################################################

# import module
# print(module.max1(6, 8))

# второй вариант вызова функции
# from module import max1
# print(max1(6, 8))

#from module import * # эта запись означает, что импортируем все функции из файла module

#import module as m1 # импортируем module как m1


###################################################################
#                               РЕКРСИЯ
###################################################################
# ЗАДАЧА. последовательность Фибоначи

# def fib(n):
#     if n in [1,2]:
#         return 1
#     return fib(n-1) + fib(n -2)

# list1 = [] #создаем список в который будем записывать числа
# for i in range(1, 10):
#     list1.append(fib(i))
# print(list1)

###################################################################
#                        АЛГОРИТМЫ СОРТИРОВКИ
###################################################################
# Два друга решили поиграть в игру: один загадывает число от 1 до 100, другой должен отгадать.
# Согласитесь, что мы можем перебирать эти значения в случайном порядке, например: 32, 27, 60,
# 73… Да, мы можем угадать в какой-то момент, но что если мы обратиться к стратегии “разделяй
# и властвуй” Обозначим друзей, друг_1 это Иван, который загадал число, друг_2 это Петр,
# который отгадывает. Итак начнем:

# def quicksort(array):
#     if len(array) <= 1:
#         return array
#     else:
#         pivot = array[0]
#         less = [i for i in array[1:] if i <= pivot]
#         greater = [i for i in array[1:] if i > pivot]
#         return quicksort(less) + [pivot] + quicksort(greater)
# print(quicksort([10, 5, 2, 3]))

# ● 1-е повторение рекурсии:
# ○ array = [10, 5, 2, 3]
# ○ pivot = 10
# ○ less = [5, 2, 3]
# ○ greater = []
# ○ return quicksort([5, 2, 3]) + [10] + quicksort([])
# ● 2-е повторение рекурсии:
# ○ array = [5, 2, 3]
# ○ pivot = 5
# ○ less = [2, 3]
# ○ greater = []
# ○ return quicksort([2, 3]) + [5] + quicksort([]) # Важно! Не забывайте, что здесь помимо вызова рекурсии
# добавляется список [10]
# ● 3-е повторение рекурсии:
# ○ array = [2, 3]
# ○ return [2, 3] # Сработал базовый случай рекурсии
# На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: [2, 3] + [5] + [10] = [2, 3, 5,10]


#########################################################################
#                              СОРТИРОВКА СЛИЯНИЕМ
#########################################################################

# def merge_sort(nums):
#     if len(nums) > 1:
#         mid = len(nums) // 2  # середина списка
#         left = nums[:mid]  # левая часть списка
#         right = nums[mid:]  # правая часть списка
#         merge_sort(left)
#         merge_sort(right)
#         i = j = k = 0
#         while i < len(left) and j < len(right):
#             if left[i] < right[j]:
#                 nums[k] = left[i]
#                 i += 1
#             else:
#                 nums[k] = right[j]
#                 j += 1
#             k += 1

#         while i < len(left):
#             nums[k] = left[i]
#             i += 1
#             k += 1

#         while j < len(right):  # Исправлено на j < len(right)
#             nums[k] = right[j]
#             j += 1
#             k += 1

# list1 = [1, 2, 3, 1, 5, 6, 3, 8, 9, 54, 4, 7]
# merge_sort(list1)

# print(list1)